<!DOCTYPE html><html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" /><title>放着, 我来</title><link rel="stylesheet" href="https://zhongl.github.io/public/css/poole.css" /><link rel="stylesheet" href="https://zhongl.github.io/public/css/syntax.css" /><link rel="stylesheet" href="https://zhongl.github.io/public/css/hyde.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:400" /><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zhongl.github.io/public/apple-touch-icon-144-precomposed.png" /><link rel="shortcut icon" href="https://zhongl.github.io/public/favicon.ico" /><script src="https://www.googletagmanager.com/gtag/js?id=UA-6664231-5"></script><script> window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-6664231-5');
    </script></head><body class=" "><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1>放着, 我来</h1><blockquote>理想和情怀是有代价的, 但好在它不是自由的枷锁, 而应该是真正的自由本身. <a href="https://weibo.com/1875401263/DDSIEbOJy">by @dcaoyuan</a></blockquote></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://zhongl.github.io/">Home</a><a class="sidebar-nav-item" href="https://github.com/zhongl">Github</a><a class="sidebar-nav-item" href="https://speakerdeck.com/zhongl/">Speaker</a><a class="sidebar-nav-item" href="http://cafusic.lofter.com/">Lofter</a></nav><p>&copy; 2021. All rights reserved</p></div></div><div class="content container"><div class="post"><h1 class="post-title">动态实时跟踪你的java程序</h1><p class="post-meta">15 Aug 2011 @<a href="https://github.com/zhongl">zhongl</a></p><input type="hidden" name="id" value="trace your java program at runtime" />
<input type="hidden" name="created" value="2011-08-15" />
<p>之前有写 <a href="https://zhongl.github.io/2010/04/05/debug-by-aop">基于AOP的日志调试</a> 讨论一种跟踪Java程序的方法, 但不是很完美.后来发现了 <a href="https://github.com/btraceio/btrace">Btrace</a> , 由于它借助动态字节码注入技术 , 实现优雅且功能强大.</p>
<p>只不过, 用起来总是磕磕绊绊的, 时常为了跟踪某个问题, 却花了大把的时间调试 <a href="https://github.com/btraceio/btrace">Btrace</a> 的脚本. 为此, 我尝试将几种跟踪模式固化成脚本模板, 待用的时候去调整一下正则表达式之类的.</p>
<p>跟踪过程往往是假设与验证的螺旋迭代过程, 反复的用 <a href="https://github.com/btraceio/btrace">BTrace</a> 跟踪目标进程, 总有那么几次莫名其妙的不可用, 最后不得不重启目标进程. 若真是线上不能停的服务, 我想这种方式还是不靠谱啊.</p>
<p>为此, 据决定自己的搞个用起来简单, 又能良好支持反复跟踪而不用重启目标进程的工具.</p>
<!--more-->
<h1 id="aop">AOP</h1>
<p>AOP 是 Btrace, jip<sup id="fnref-1"><a class="footnote-ref" href="#fn-1">1</a></sup>等众多监测工具的核心思想, 用一段代码最容易说明:</p>
<pre><code class="language-java">public void say(String words){
  Trace.enter();
  System.out.println(words);
  Trace.exit();
}
</code></pre>
<p>如上,  <code>Trace.enter()</code> 和  <code>Trace.exit()</code> 将 <code>say(words)</code> 内的代码环抱起来, 对方法进出的进行切面的处理, 便可获取运行时的上下文, 如:</p>
<ul>
<li>调用栈</li>
<li>当前线程</li>
<li>时间消耗</li>
<li>参数与返回值</li>
<li>当前实例状态</li>
</ul>
<h1 id="实现的选择">实现的选择</h1>
<p>实现切面的方式, 我知道的有以下几种:</p>
<h2 id="代理装饰器模式">代理(装饰器)模式</h2>
<p>设计模式中装饰器模式和代理模式, 尽管解决的问题域不同, 代码实现是非常相似, 均可以实现切面处理, 这里视为等价. 依旧用代码说明:</p>
<pre><code class="language-java">interface Person {
  void say(String words);
}

class Officer implements Person {
  public void say(String words) { lie(words); }
  private void lie(String words) {...}
}

class Proxy implements Person {
  private final Officer officer;
  public Proxy(Officer officer) { this.officer = officer; }
  public void say(String words) {
    enter();
    officer.say(words);
    exit();
  }
  private void enter() { ... }
  private void exit() { ... }
}

Person p = new Proxy(new Officer());
</code></pre>
<p>很明显, 上述 <code>enter()</code>  和 <code>exit()</code> 是实现切面的地方, 通过获取 <code>Officer</code> 的 <code>Proxy</code> 实例, 便可对 <code>Officer</code> 实例的行为进行跟踪. 这种方式实现起来最简单, 也最直接.</p>
<h2 id="java-proxy">Java Proxy</h2>
<p>Java Proxy<sup id="fnref-2"><a class="footnote-ref" href="#fn-2">2</a></sup> 是 JDK 内置的代理 API, 借助反射机制实现. 用它来是完成切面则会是:</p>
<pre><code class="language-java">class ProxyInvocationHandler implements InvocationHandler {
  private final Object target;
  public ProxyInvocationHandler(Object target) { this.target = target;}
  public Object handle(Object proxy, Method method, Object[] args) {
    enter();
    method.invoke(target, args);
    exit();
  }
  private void enter() { ... }
  private void exit() { ... }
}
ClassLoader loader = ...
Class&lt;?&gt;[]  interfaces = {Person.class};
Person p = (Person)Proxy.newInstance(loader, interfaces, new ProxyInvocationHandler(new Officer()));
</code></pre>
<p>相比较上一中方法, 这种不太易读, 但更为通用, 对具体实现依赖很少.</p>
<h2 id="aspectj">AspectJ</h2>
<p>AspectJ<sup id="fnref-3"><a class="footnote-ref" href="#fn-3">3</a></sup> 是基于字节码操作的 AOP 实现, 相比较 Java proxy, 它会显得对调用更&quot;透明&quot;, 编写更简明(类似DSL), 性能更好. 如下代码:</p>
<pre><code class="language-java">pointcut say(): execute(* say(..))
before(): say() { ... }
after() : say() { ... }
</code></pre>
<p>AspectJ 实现切面的时机有两种:</p>
<ul>
<li>静态编译</li>
<li>类加载期编织(load-time weaving)</li>
</ul>
<p>并且它对IDE的支持很丰富.</p>
<h2 id="cglib">CGlib</h2>
<p>与 AspectJ 一样 CGlib<sup id="fnref-4"><a class="footnote-ref" href="#fn-4">4</a></sup> 也是操作字节码来实现 AOP 的, 使用上与 Java Proxy 非常相似, 只是不像 Java Proxy 对接口有依赖, 我们熟知的 Spring, Guice 之类的 IoC 容器实现 AOP 都是使用它来完成的.</p>
<pre><code class="language-java">class Callback implements MethodInterceptor {
  public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable {
    enter();
    proxy.invokeSuper(obj, args);
    exit();
  }
  private void enter() { ... }
  private void exit() { ... }
}
Enhancer e = new Enhancer();
e.setSuperclass(Officer.class);
e.setCallback(new Callback());
Person p = e.create();
</code></pre>
<h2 id="字节码操纵">字节码操纵</h2>
<p>上面四种方法各有适用的场景, 但唯独对运行着的Java进程进行动态的跟踪支持不了, 当然也许是我了解的不够深入, 若有基于上述方案的办法还请不吝赐教.</p>
<p>还是回到Btrace<sup id="fnref-5"><a class="footnote-ref" href="#fn-5">5</a></sup>的思路上来, 在理解了它借助 <code>java.lang.instrument</code> 进行字节码注入的实现原理<sup id="fnref-6"><a class="footnote-ref" href="#fn-6">6</a></sup>后, 实现动态变化跟踪方式或目标应该没有问题.</p>
<p>借下来的问题, 如何操作(注入)字节码实现切面的处理. 可喜的是, 构建自己的监测工具<sup id="fnref-7"><a class="footnote-ref" href="#fn-7">7</a></sup> 一文给我提供了一个很好的切入点. 在此基础上, 经过一些对 ASM<sup id="fnref-8"><a class="footnote-ref" href="#fn-8">8</a></sup> 的深入研究, 可以实现:</p>
<ul>
<li>方法调用进入时, 获取当前实例 (<code>this</code>)  和 参数值列表;</li>
<li>方法调用出去时, 获取返回值;</li>
<li>方法异常抛出时, 触发回调并获取异常实例.</li>
</ul>
<p>其切面实现的核心代码如下:</p>
<pre><code class="language-java"> private static class ProbeMethodAdapter extends AdviceAdapter {

    protected ProbeMethodAdapter(MethodVisitor mv, int access, String name, String desc, String className) {
      super(mv, access, name, desc);
      start = new Label();
      end = new Label();
      methodName = name;
      this.className = className;
    }

    @Override
    public void visitMaxs(int maxStack, int maxLocals) {
      mark(end);
      catchException(start, end, Type.getType(Throwable.class));
      dup();
      push(className);
      push(methodName);
      push(methodDesc);
      loadThis();
      invokeStatic(Probe.TYPE, Probe.EXIT);
      visitInsn(ATHROW);
      super.visitMaxs(maxStack, maxLocals);
    }

    @Override
    protected void onMethodEnter() {
      push(className);
      push(methodName);
      push(methodDesc);
      loadThis();
      loadArgArray();
      invokeStatic(Probe.TYPE, Probe.ENTRY);
      mark(start);
    }

    @Override
    protected void onMethodExit(int opcode) {
      if (opcode == ATHROW) return; // do nothing, @see visitMax
      prepareResultBy(opcode);
      push(className);
      push(methodName);
      push(methodDesc);
      loadThis();
      invokeStatic(Probe.TYPE, Probe.EXIT);
    }

    private void prepareResultBy(int opcode) {
      if (opcode == RETURN) { // void
        push((Type) null);
      } else if (opcode == ARETURN) { // object
        dup();
      } else {
        if (opcode == LRETURN || opcode == DRETURN) { // long or double
          dup2();
        } else {
          dup();
        }
        box(Type.getReturnType(methodDesc));
      }
    }

    private final String className;
    private final String methodName;
    private final Label start;
    private final Label end;
}
</code></pre>
<p>更多参考请见这里的 <a href="https://github.com/zhongl/atMonitor">Demo</a>, 它是 javaagent , 在伴随宿主进程启动后, 提供 MBean 可用 jconsole 进行动态跟踪的管理.</p>
<h1 id="后续的方向">后续的方向</h1>
<ul>
<li>提供基于Web的远程交互界面;</li>
<li>提供基于Shell的本地命令行接口;</li>
<li>提供Profile统计和趋势输出;</li>
<li>提供跟踪日志定位与分析.</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-profiling/index.html?ca=drs-">常用 Java Profiling 工具的分析与比较</a></li>
<li><a href="https://www.ibm.com/developerworks/java/library/j-aopwork10/?S_TACT=105AGX52&amp;S_CMP=cn-a-j">AOP@Work: Performance monitoring with AspectJ</a></li>
<li><a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">The JavaTM Virtual Machine Specification (2nd)</a></li>
<li><a href="http://www.slideshare.net/cafusic/jvm20101228">来自rednaxelafx的JVM分享</a></li>
<li><a href="http://commons.apache.org/bcel/manual.html">BCEL</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn-1">
<p>http://jiprof.sourceforge.net/</p>
<a href="#fnref-1" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-2">
<p>http://download.oracle.com/javase/6/docs/api/java/lang/reflect/Proxy.html</p>
<a href="#fnref-2" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-3">
<p>http://www.eclipse.org/aspectj/</p>
<a href="#fnref-3" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-4">
<p>http://cglib.sourceforge.net/</p>
<a href="#fnref-4" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-5">
<p>http://kenai.com/projects/btrace/pages/UserGuide</p>
<a href="#fnref-5" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-6">
<p>http://kenwublog.com/btrace-theory-analysis</p>
<a href="#fnref-6" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-7">
<p>http://www.ibm.com/developerworks/cn/java/j-jip/index.html?ca=drs</p>
<a href="#fnref-7" class="footnote-backref">&#8617;</a>
</li>
<li id="fn-8">
<p>http://download.forge.objectweb.org/asm/asm-guide.pdf</p>
<a href="#fnref-8" class="footnote-backref">&#8617;</a>
</li>
</ol>
</div>
<div><a href="https://zhongl.github.io/tags/aop" class="post-badge">aop</a><a href="https://zhongl.github.io/tags/aspectj" class="post-badge">aspectj</a><a href="https://zhongl.github.io/tags/btrace" class="post-badge">btrace</a><a href="https://zhongl.github.io/tags/cglib" class="post-badge">cglib</a><a href="https://zhongl.github.io/tags/java" class="post-badge">java</a><a href="https://github.com/zhongl/zhongl.github.com/issues/4" class="post-comment">Comment(0)</a></div><div></div></div></div></body></html>